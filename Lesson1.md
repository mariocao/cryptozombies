## Lesson 1: Making the Zombie Factory

### Basics
Version Pragma:
```
pragma solidity ^0.4.19;
```

Contracts:
```
contract HelloWorld {

}
```

### Basic Variables

State variables: permanently stored in contract storage
* Booleans: bool
* Unsigned integers: uint8, uint16, uint32, uint256 (aliases: uint or int)
* Strings: string

```
uint varName = 16;
```

Operators:
* ! (logical negation)
* && (logical conjunction, “and”)
* || (logical disjunction, “or”)
* == (equality)
* != (inequality)

Type casting as for example:
```
uint8 a = 5;
uint b = 6;
uint8 c = a * uint8(b);
```

### Math operations

Basic Operations:
* Addition: x + y
* Subtraction: x - y,
* Multiplication: x * y
* Division: x / y
* Modulus / remainder: x % y 
* Exponentiation: x ** y

### Structs

Complex data types:
```
struct Person {
  uint age;
  string name;
}
```

### Arrays

2 types of arrays:
* fixed
* dynamic

```
// Array with a fixed length of 2 elements:
uint[2] fixedArray;
// another fixed Array, can contain 5 strings:
string[5] stringArray;
// a dynamic Array - has no fixed size, can keep growing:
uint[] dynamicArray;
```

Arrays can be declared `public`, and solidity will automatically create a **getter** method for it.
```
Person[] public people;
```

Pushing new array element:
```
Person[] public people;
// create a New Person:
Person satoshi = Person(172, "Satoshi");
// Add that person to the Array:
people.push(satoshi);
```

### Basic Function visibility

Function declaration is as follows:
```
function eatHamburgers(string _name, uint _amount) {

}
```

Functions are **public** by default, for declaring **private** functions:
```
uint[] numbers;

function _addToArray(uint _number) private {
  numbers.push(_number) {
}
```

Note: private functions as well as functions parameters start with an underscore by convention.

To declare the **return values**:
```
string greeting = "What's up dog";

function sayHello() public returns (string) {
  return greeting;
}

```

There also some **function modifiers**, such as:
* view: only reads data (not modifies)
* pure: not reading or modifying data

```
function sayHello() public view returns (string) {

function _multiply(uint a, uint b) private pure returns (uint) {
  return a * b;
}
```

### Built-in hash algorithm

Ethereum has the hash function keccak256:
```
keccak256("aaaab");
```

### Events

Events are a way for your contract to communicate that something happened on the blockchain to your app front-end.

```
// declare the event
event IntegersAdded(uint x, uint y, uint result);

function add(uint _x, uint _y) public {
  uint result = _x + _y;
  // fire an event to let the app know the function was called:
  IntegersAdded(_x, _y, result);
  return result;
}
```

The front-end might listen to the event as follows:
```
YourContract.IntegersAdded(function(error, result) { 
  // do something with result
}
```

### Web3.js

Example of using a contract from front-end:
```
// Here's how we would access our contract:
var abi = /* abi generated by the compiler */
var ZombieFactoryContract = web3.eth.contract(abi)
var contractAddress = /* our contract address on Ethereum after deploying */
var ZombieFactory = ZombieFactoryContract.at(contractAddress)
// `ZombieFactory` has access to our contract's public functions and events
```
